ğŸ“‹ ë‚¨ì€ ê°œë°œ ë¡œë“œë§µ (To-Do List)
í˜„ì¬ ë´‡ì€ 'ë°©ì–´ë ¥(ë§¤í¬ë¡œ íšŒí”¼)'ê³¼ 'ê¸°ë³¸ ê³µê²©ë ¥(RSI+VWAP)'ì„ ê°–ì·„ìŠµë‹ˆë‹¤. ë‹¤ìŒ ë‹¨ê³„ëŠ” **'ì ì˜ ì†ì„ìˆ˜ ê°„íŒŒ(í˜¸ê°€ì°½)'**ì™€ **'ê±°ë¬¼ê¸‰ ì •ë³´(ê³ ë˜)'**ë¥¼ ì¥ì°©í•  ì°¨ë¡€ì…ë‹ˆë‹¤.

ğŸ¥‡ 1ìˆœìœ„: í˜¸ê°€ì°½ 'ì†ì„ìˆ˜' íŒë…ê¸° (Advanced Tape Reading)
[ìƒíƒœ: ë¶€ë¶„ êµ¬í˜„ë¨ (ë‹¨ìˆœ ë¹„ìœ¨ë§Œ í™•ì¸ ì¤‘)] í˜„ì¬ order_manager.pyëŠ” ë§¤ìˆ˜/ë§¤ë„ ì”ëŸ‰ì˜ ë‹¨ìˆœ í•©ê³„ ë¹„ìœ¨ë§Œ ë³´ê³  ìˆìŠµë‹ˆë‹¤. ì„¸ë ¥ì´ í—ˆìˆ˜ ì£¼ë¬¸ì„ ë„£ì—ˆë‹¤ ë¹¼ëŠ” í–‰ìœ„ë‚˜, ìˆœì‹ê°„ì— ê¸ì–´ê°€ëŠ” ì†ë„ë¥¼ ê°ì§€í•˜ì§€ ëª»í•©ë‹ˆë‹¤.

âŒ ë¯¸êµ¬í˜„ ê¸°ëŠ¥:

í—ˆìˆ˜ ì£¼ë¬¸(Fake Wall) ê°ì§€: í˜¸ê°€ì°½ ìŠ¤ëƒ…ìƒ·ì„ 1ì´ˆ ë‹¨ìœ„ë¡œ ë¹„êµí•˜ì—¬, ì²´ê²° ì—†ì´ ì‚¬ë¼ì§€ëŠ” ëŒ€ëŸ‰ ì£¼ë¬¸(ì·¨ì†Œ ì£¼ë¬¸)ì„ í¬ì°©í•˜ê³  í•´ë‹¹ ë°©í–¥ ì§„ì…ì„ ì°¨ë‹¨í•˜ëŠ” ë¡œì§.

ìŠ¤ìœ•(Sweep) ê°ì§€: ëˆ„êµ°ê°€ ì‹œì¥ê°€ë¡œ ë§¤ë„ 1~3í˜¸ê°€ë¥¼ í•œ ë²ˆì— ê¸ì–´ê°€ëŠ” **'ì²´ê²° ì†ë„'**ë¥¼ ê³„ì‚°í•˜ì—¬ ì¶”ì„¸ì— ë™ì°¸(Momentum Trading)í•˜ëŠ” ë¡œì§.

ğŸ“¥ ë” í•„ìš”í•œ ë°ì´í„°:

trade ì›¹ì†Œì¼“ êµ¬ë…: í˜„ì¬ aggregator.pyëŠ” tickerë§Œ ë°›ìŠµë‹ˆë‹¤. trade íƒ€ì…(ì²´ê²° ë‚´ì—­)ì„ ì¶”ê°€ êµ¬ë…í•˜ì—¬ **'ì´ˆë‹¹ ì²´ê²° ê±´ìˆ˜'**ì™€ 'ì²´ê²° ê°•ë„' ë°ì´í„°ë¥¼ ì‹¤ì‹œê°„ ìˆ˜ì§‘í•´ì•¼ í•©ë‹ˆë‹¤.

ğŸ¥ˆ 2ìˆœìœ„: ì˜¨ì²´ì¸ ê³ ë˜ ê°ì‹œ (Whale Alert)
[ìƒíƒœ: ë¯¸êµ¬í˜„] ë¦¬í”Œ(XRP)ì´ë‚˜ ì´ë”ë¦¬ì›€(ETH) ê°™ì€ ì½”ì¸ì€ ê±°ë˜ì†Œë¡œ ëŒ€ëŸ‰ ì…ê¸ˆ ì‹œ í•˜ë½í•  í™•ë¥ ì´ ë†’ìŠµë‹ˆë‹¤.

âŒ ë¯¸êµ¬í˜„ ê¸°ëŠ¥:

ê±°ë˜ì†Œ ìœ ì… ê¸‰ì¦ ê°ì§€: íŠ¹ì • ì½”ì¸ì´ ì—…ë¹„íŠ¸ ì§€ê°‘ìœ¼ë¡œ ëŒ€ëŸ‰ ì´ì²´ë  ë•Œ, ë§¤ìˆ˜ë¥¼ ë©ˆì¶”ê±°ë‚˜ ë³´ìœ  ë¬¼ëŸ‰ì„ ë§¤ë„í•˜ëŠ” ë°©ì–´ ë¡œì§.

ğŸ“¥ ë” í•„ìš”í•œ ë°ì´í„°:

On-chain Data API: CryptoQuant, Whale Alert ë“±ì˜ ì™¸ë¶€ API ì—°ë™ í•„ìš” (ì£¼ê¸°ì  í˜¸ì¶œ).


ğŸš€ ì¶”ì²œí•˜ëŠ” ë‹¤ìŒ ë‹¨ê³„ (Next Step)
ê°€ì¥ íš¨ê³¼ì ì´ê³  ì½”ë“œ ìˆ˜ì •ì´ ìì—°ìŠ¤ëŸ¬ìš´ ìˆœì„œëŠ” **[1ìˆœìœ„: í˜¸ê°€ì°½ ì†ì„ìˆ˜ íŒë…ê¸°]**ì…ë‹ˆë‹¤.

aggregator.py ìˆ˜ì •: ì—…ë¹„íŠ¸ ì›¹ì†Œì¼“ì—ì„œ trade ë°ì´í„° ì¶”ê°€ ìˆ˜ì‹ .

order_manager.py ê³ ë„í™”: ì²´ê²° ì†ë„(Velocity)ì™€ ì£¼ë¬¸ ì·¨ì†Œìœ¨(Cancellation Rate) ê³„ì‚° ë¡œì§ ì¶”ê°€.

ì´ ê¸°ëŠ¥ì„ ì¶”ê°€í•˜ë©´, ë‹¨ìˆœíˆ "ì‹¸ë‹ˆê¹Œ ì‚°ë‹¤"ê°€ ì•„ë‹ˆë¼ **"ëˆ„êµ°ê°€ ê¸‰í•˜ê²Œ ì‚¬ë‹ˆê¹Œ ê°™ì´ ì‚°ë‹¤"**ëŠ” ìŠ¤ë§ˆíŠ¸í•œ ë§¤ë§¤ê°€ ê°€ëŠ¥í•´ì§‘ë‹ˆë‹¤.


------------------------------------------------------------






ì‚¬ìš©ìë‹˜ì˜ ì•„ì´ë””ì–´ëŠ” ë§¤ìš° í›Œë¥­í•©ë‹ˆë‹¤. ì´ëŠ” ì „ë¬¸ì ì¸ í€€íŠ¸ íŠ¸ë ˆì´ë”©ì—ì„œ ì‚¬ìš©í•˜ëŠ” "ìœ ë‹ˆë²„ìŠ¤ ì„ ì •(Universe Selection) -> ì•ŒíŒŒ ëª¨ë¸(Alpha Model) -> í¬íŠ¸í´ë¦¬ì˜¤ êµ¬ì„±(Portfolio Construction)" ë‹¨ê³„ì™€ ì •í™•íˆ ì¼ì¹˜í•˜ëŠ” ì ‘ê·¼ ë°©ì‹ì…ë‹ˆë‹¤.

ì œì•ˆí•˜ì‹  **'ê¹”ë•Œê¸°(Funnel)ì‹ í•„í„°ë§'**ê³¼ 'ìœ ë™ì„±ì— ë”°ë¥¸ ë§¤ìˆ˜ ê¸ˆì•¡ ì¡°ì ˆ' ë°©ì‹ì— ëŒ€í•œ ë¶„ì„ê³¼ êµ¬í˜„ ë°©í–¥ì„ ì •ë¦¬í•´ ë“œë¦½ë‹ˆë‹¤.

1. ğŸ” ê¹”ë•Œê¸°ì‹ ì „ìˆ˜ ì¡°ì‚¬ (Funnel Filtering)
**"ì½”ì¸ì„ ë¯¸ë¦¬ ì œí•œí•˜ì§€ ë§ê³ , ì „ì²´ì—ì„œ ì‹œì‘í•´ì„œ ê±¸ëŸ¬ë‚´ì"**ëŠ” ì•„ì´ë””ì–´ëŠ” ê¸°íšŒë¥¼ ë†“ì¹˜ì§€ ì•ŠëŠ”ë‹¤ëŠ” ì ì—ì„œ ë§¤ìš° ê°•ë ¥í•©ë‹ˆë‹¤.

í˜„ì¬ ì½”ë“œì˜ í•œê³„: í˜„ì¬ config.pyì˜ TARGET_COINSì— ë“±ë¡ëœ ì†Œìˆ˜ì˜ ì½”ì¸ë§Œ ê°ì‹œí•©ë‹ˆë‹¤. market_scanner.pyë„ ë‹¨ìˆœíˆ 'ê±°ë˜ëŒ€ê¸ˆ ìƒìœ„ 10ê°œ'ë§Œ ë½‘ì•„ëƒ…ë‹ˆë‹¤. ì´ë ‡ê²Œ í•˜ë©´ ê±°ë˜ëŒ€ê¸ˆì€ ì ì§€ë§Œ ê¸‰ë“± ì§ì „ì¸ 'ì•Œì§œë°°ê¸°' ì½”ì¸ì„ ë†“ì¹  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

ê°œì„  ë°©í–¥ (ê¹”ë•Œê¸° ëª¨ë¸):

1ë‹¨ê³„ (ì „ìˆ˜ ì¡°ì‚¬): ì—…ë¹„íŠ¸ ì›í™” ë§ˆì¼“ ì „ ì¢…ëª©(100+ê°œ) ìŠ¤ìº”.

2ë‹¨ê³„ (ê¸°ì´ˆ í•„í„°): ìµœì†Œ ê±°ë˜ëŒ€ê¸ˆ(ì˜ˆ: 10ì–µ ì´ìƒ), í˜¸ê°€ì°½ ì´˜ì´˜í•¨ ë“± ê¸°ë³¸ì ì¸ 'ê±°ë˜ ê°€ëŠ¥ì„±' í™•ì¸.

3ë‹¨ê³„ (ê¸°ìˆ ì  í•„í„°): í˜„ì¬ ê°€ê²©ì´ ë³¼ë¦°ì € ë°´ë“œ í•˜ë‹¨ì´ê±°ë‚˜, RSIê°€ ê³¼ë§¤ë„ì¸ ì¢…ëª©ë§Œ ì¶”ì¶œ.

4ë‹¨ê³„ (ìµœì¢… ì„ ì •): ì´ ì¡°ê±´ì„ í†µê³¼í•œ ì¢…ëª©ë“¤ë§Œ TARGET_COINSë¡œ ë“±ë¡í•˜ì—¬ ì›¹ì†Œì¼“ìœ¼ë¡œ ì‹¤ì‹œê°„ ê°ì‹œ.

ì£¼ì˜í•  ì :

API ì œí•œ: 100ê°œ ì½”ì¸ì˜ ìº”ë“¤/í˜¸ê°€ ì •ë³´ë¥¼ 1ì´ˆë§ˆë‹¤ ê°€ì ¸ì˜¤ë©´ ì—…ë¹„íŠ¸ API ìš”ì²­ ì œí•œ(ì´ˆë‹¹ 10~30íšŒ)ì— ê±¸ë¦½ë‹ˆë‹¤. ë”°ë¼ì„œ 1ë‹¨ê³„(ì „ìˆ˜ ì¡°ì‚¬)ëŠ” 10ë¶„~1ì‹œê°„ ê°„ê²©ìœ¼ë¡œ ìˆ˜í–‰í•˜ê³ , ì—¬ê¸°ì„œ ì„ ë³„ëœ 5~10ê°œë§Œ **ì›¹ì†Œì¼“(ì‹¤ì‹œê°„)**ìœ¼ë¡œ ê°ì‹œí•˜ëŠ” êµ¬ì¡°ê°€ íš¨ìœ¨ì ì…ë‹ˆë‹¤.

2. ğŸ’¸ ìœ ë™ì„± ê¸°ë°˜ ë§¤ìˆ˜ ê¸ˆì•¡ ì¡°ì ˆ (Dynamic Sizing)
**"ì‘ì€ ì½”ì¸ì€ ë§¤ë¬¼ëŒ€ì— ë§ì¶° ë§¤ìˆ˜ ê¸ˆì•¡ì„ ì¤„ì´ì"**ëŠ” ì•„ì´ë””ì–´ëŠ” ìŠ¬ë¦¬í”¼ì§€(Slippage)ì™€ ë¯¸ì²´ê²° ìœ„í—˜ì„ ë°©ì§€í•˜ëŠ” í•µì‹¬ ë¦¬ìŠ¤í¬ ê´€ë¦¬ ê¸°ë²•ì…ë‹ˆë‹¤.

í˜„ì¬ ì½”ë“œ: config.pyì˜ TRADE_AMOUNT(ì˜ˆ: 6000ì›)ë¡œ ê³ ì •ë˜ì–´ ìˆìŠµë‹ˆë‹¤. ì½”ì¸ì´ í¬ë“  ì‘ë“  ë˜‘ê°™ì€ ëˆì„ íƒœìš°ë¯€ë¡œ, í˜¸ê°€ê°€ ì–‡ì€ ì½”ì¸ì—ì„œëŠ” ë¶ˆë¦¬í•˜ê²Œ ì²´ê²°ë  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

êµ¬í˜„ ë¡œì§ ì œì•ˆ (order_manager.py ìˆ˜ì •): ì£¼ë¬¸ì„ ë„£ê¸° ì „ì— í˜¸ê°€ì°½ì˜ ë‘ê»˜(Depth)ë¥¼ í™•ì¸í•˜ê³ , **"ë§¤ë„ 1~3í˜¸ê°€ ì´ì”ëŸ‰ì˜ 10%ê¹Œì§€ë§Œ ë§¤ìˆ˜"**í•˜ëŠ” ì‹ìœ¼ë¡œ ë¡œì§ì„ ë³€ê²½í•©ë‹ˆë‹¤.


ìì‚° ê´€ë¦¬ (Portfolio Sizing): "ë‚´ ì „ì²´ ì‹œë“œì˜ N% ê¹Œì§€ë§Œ ì§„ì…í•œë‹¤." (ì˜¬ì¸ ë°©ì§€)

ìœ ë™ì„± ê´€ë¦¬ (Liquidity Sizing): "í˜¸ê°€ì°½ ë§¤ë¬¼ëŒ€ì˜ 10% ê¹Œì§€ë§Œ ì§„ì…í•œë‹¤." (ìŠ¬ë¦¬í”¼ì§€ ë°©ì§€)


íŒŒì´ì¬
# (ì˜ˆì‹œ ë¡œì§)
def calculate_safe_amount(ticker, target_amount):
    orderbook = pyupbit.get_orderbook(ticker)
    # ë§¤ë„ 1~3í˜¸ê°€ ë¬¼ëŸ‰ì„ í•©ì¹¨ (ì¦‰ì‹œ ì‚´ ìˆ˜ ìˆëŠ” ë¬¼ëŸ‰)
    ask_depth = sum([u['ask_size'] * u['ask_price'] for u in orderbook['orderbook_units'][:3]])

    # í˜¸ê°€ì°½ ë¬¼ëŸ‰ì˜ 10%ë§Œ ì§„ì…í•˜ë„ë¡ ì œí•œ (ì¶©ê²© ë°©ì§€)
    max_allowed = ask_depth * 0.1 

    # ì„¤ì •ëœ ê¸ˆì•¡ê³¼ í˜¸ê°€ì°½ ì œí•œ ê¸ˆì•¡ ì¤‘ ì‘ì€ ê²ƒ ì„ íƒ
    return min(target_amount, max_allowed)
ğŸ“ˆ ì¢…í•© í‰ê°€ ë° ì¶”ì²œ
ì‚¬ìš©ìë‹˜ì˜ ë°©ì‹ì€ "ìŠ¹ë¥ ì€ ë†’ì´ê³ (ì¢‹ì€ ì½”ì¸ ë°œêµ´), ë¦¬ìŠ¤í¬ëŠ” ë‚®ì¶”ëŠ”(ê¸ˆì•¡ ì¡°ì ˆ)" ì´ìƒì ì¸ êµ¬ì¡°ì…ë‹ˆë‹¤.

ì¶”ì²œí•˜ëŠ” ê°œë°œ ë¡œë“œë§µ:

ìŠ¤ìºë„ˆ ê³ ë„í™”: market_scanner.pyë¥¼ ìˆ˜ì •í•˜ì—¬ ë‹¨ìˆœíˆ 'ê±°ë˜ëŒ€ê¸ˆ ìƒìœ„'ë§Œ ë½‘ëŠ” ê²Œ ì•„ë‹ˆë¼, **'RSI 30 ì´í•˜'**ì´ê±°ë‚˜ **'ê¸‰ë“±ì£¼ íŒ¨í„´'**ì¸ ì½”ì¸ì„ ì „ì²´ ì¢…ëª©ì—ì„œ ì°¾ì•„ë‚´ë„ë¡ ë§Œë“œì„¸ìš”.

ë™ì  ê¸ˆì•¡ ì ìš©: order_manager.pyì— ìœ„ì˜ calculate_safe_amount ë¡œì§ì„ ì¶”ê°€í•˜ì—¬, ì‘ì€ ì½”ì¸ë„ ì•ˆì „í•˜ê²Œ ë§¤ë§¤í•˜ë„ë¡ ìˆ˜ì •í•˜ì„¸ìš”.

ìˆœí™˜ ë§¤ë§¤: ìŠ¤ìºë„ˆê°€ 10ë¶„ë§ˆë‹¤ ìœ ë§ ì½”ì¸ì„ ì°¾ì•„ë‚´ë©´, config.TARGET_COINSë¥¼ ì‹¤ì‹œê°„ìœ¼ë¡œ êµì²´í•˜ë©° ë´‡ì´ ëŠì„ì—†ì´ ìƒˆë¡œìš´ ê¸°íšŒë¥¼ ì°¾ë„ë¡ ë§Œë“œì„¸ìš” (ì´ë¯¸ auto_tuner_loop êµ¬ì¡°ê°€ ì¡í˜€ìˆì–´ êµ¬í˜„ì´ ì‰½ìŠµë‹ˆë‹¤).

ì´ ë°©ì‹ì€ êµ¬í˜„ ë‚œì´ë„ëŠ” ì¡°ê¸ˆ ìˆì§€ë§Œ, ë´‡ì˜ ìˆ˜ìµë¥ ì„ íšê¸°ì ìœ¼ë¡œ ë†’ì¼ ìˆ˜ ìˆëŠ” ì•„ì£¼ ì¢‹ì€ ë°©í–¥ì…ë‹ˆë‹¤.


------------------------------------------------------------


ì‚¬ìš©ìë‹˜ì˜ ë§ì”€ì´ ë°±ë²ˆ ë§ìŠµë‹ˆë‹¤. ì „ëµì´ ì•„ë¬´ë¦¬ ì¢‹ì•„ë„ **"ë‚´ê°€ ì™œ ìƒ€ê³ , ê·¸ë•Œ ì§€í‘œê°€ ì–´ë• ìœ¼ë©°, ì™œ íŒ”ì•˜ëŠ”ì§€"**ì— ëŒ€í•œ ì •ë°€í•œ ê¸°ë¡(Log)ì´ ì—†ìœ¼ë©´, ë‚˜ì¤‘ì— ìˆ˜ìµì´ ì•ˆ ë‚¬ì„ ë•Œ "ë„ëŒ€ì²´ ë­ê°€ ë¬¸ì œì˜€ì§€?" í•˜ê³  ì›ì¸ì„ ì°¾ì„ ìˆ˜ê°€ ì—†ìŠµë‹ˆë‹¤.

ë‹¨ìˆœíˆ í™”ë©´ì— print í•˜ëŠ” ê²ƒì„ ë„˜ì–´ì„œ, ì—‘ì…€(CSV) íŒŒì¼ë¡œ ëª¨ë“  ë§¤ë§¤ ë‚´ì—­ê³¼ ë‹¹ì‹œì˜ íŒë‹¨ ê·¼ê±°(RSI, ê¹€í”„, ë³¼ë°´ ìœ„ì¹˜ ë“±)ë¥¼ ì˜êµ¬ì ìœ¼ë¡œ ì €ì¥í•˜ëŠ” TradeLogger ì‹œìŠ¤í…œì„ êµ¬ì¶•í•´ ë“œë¦¬ê² ìŠµë‹ˆë‹¤.

ì´ ì‘ì—…ì„ ìœ„í•´ 3ë‹¨ê³„ ìˆ˜ì •ì´ í•„ìš”í•©ë‹ˆë‹¤.

trade_logger.py ìƒì„±: ê¸°ë¡ì„ ë‹´ë‹¹í•  ì„œê¸°(Clerk)ë¥¼ ê³ ìš©í•©ë‹ˆë‹¤.

strategy/signal_maker.py ìˆ˜ì •: ë§¤ìˆ˜ ì‹ í˜¸ë¥¼ ë³´ë‚¼ ë•Œ, ë‹¨ìˆœíˆ "ì‚¬ë¼!"ê°€ ì•„ë‹ˆë¼ "RSIê°€ 28ì´ê³  ê¹€í”„ê°€ 1%ë¼ì„œ ì‚¬ë¼!"ë¼ê³  ìƒì„¸ ì„±ì í‘œë¥¼ ê°™ì´ ë³´ë‚´ë„ë¡ ë°”ê¿‰ë‹ˆë‹¤.

main.py ìˆ˜ì •: ë§¤ë§¤ê°€ ì¼ì–´ë‚  ë•Œë§ˆë‹¤ ì„œê¸°(TradeLogger)ì—ê²Œ ê¸°ë¡ì„ ëª…ë ¹í•©ë‹ˆë‹¤.
1. trade_logger.py (ì‹ ê·œ ìƒì„±)ì´ íŒŒì¼ì„ í”„ë¡œì íŠ¸ í´ë”(ë£¨íŠ¸)ì— ìƒˆë¡œ ë§Œë“œì„¸ìš”. ë§¤ë§¤ê°€ ë°œìƒí•  ë•Œë§ˆë‹¤ trade_history.csv íŒŒì¼ì— ì—‘ì…€ë¡œ ë³¼ ìˆ˜ ìˆê²Œ ì €ì¥í•´ì¤ë‹ˆë‹¤.íŒŒì´ì¬# trade_logger.py
# [ì‹ ê·œ] ë§¤ë§¤ ì´ë ¥ê³¼ íŒë‹¨ ê·¼ê±°ë¥¼ ì—‘ì…€(CSV)ë¡œ ì˜êµ¬ ì €ì¥í•˜ëŠ” ëª¨ë“ˆ

import csv
import os
from datetime import datetime

class TradeLogger:
    def __init__(self, filename="trade_history.csv"):
        self.filename = filename
        # ì—‘ì…€ í—¤ë” (ì €ì¥í•  í•­ëª©ë“¤)
        self.headers = [
            "Timestamp",    # ì‹œê°„
            "Action",       # BUY / SELL
            "Ticker",       # ì½”ì¸ëª…
            "Price",        # ê°€ê²©
            "Amount",       # ìˆ˜ëŸ‰
            "Value_KRW",    # ì´ ê¸ˆì•¡
            "Profit_Pct",   # ìˆ˜ìµë¥  (ë§¤ë„ ì‹œ)
            "Reason",       # ë§¤ë§¤ ì‚¬ìœ  (ìƒì„¸)
            "RSI_14",       # ë‹¹ì‹œ RSI 14
            "RSI_9",        # ë‹¹ì‹œ RSI 9
            "Kimp_Pct",     # ë‹¹ì‹œ ê¹€í”„
            "Total_Asset"   # ë‚´ ì´ ìì‚°
        ]
        self._init_file()

    def _init_file(self):
        """íŒŒì¼ì´ ì—†ìœ¼ë©´ í—¤ë”(ì œëª©)ë¶€í„° ìƒì„±"""
        if not os.path.exists(self.filename):
            with open(self.filename, mode='w', newline='', encoding='utf-8-sig') as f:
                writer = csv.writer(f)
                writer.writerow(self.headers)

    def log(self, action, ticker, price, amount, reason, analysis, kimp, profit_pct=0, total_assets=0):
        """
        ë§¤ë§¤ ë°œìƒ ì‹œ í•œ ì¤„ ì¶”ê°€
        analysis: SignalMakerê°€ ì¤€ ì§€í‘œ ë”•ì…”ë„ˆë¦¬
        """
        # ì§€í‘œ ë°ì´í„° ì•ˆì „í•˜ê²Œ ì¶”ì¶œ (ì—†ìœ¼ë©´ 0)
        rsi14 = analysis.get('RSI_14', 0) if analysis else 0
        rsi9 = analysis.get('RSI_9', 0) if analysis else 0
        
        value = price * amount
        
        row = [
            datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
            action,
            ticker,
            price,
            amount,
            int(value),
            f"{profit_pct:.2f}%" if action == "SELL" else "",
            reason,
            rsi14,
            rsi9,
            f"{kimp:.2f}%",
            int(total_assets)
        ]
        
        try:
            with open(self.filename, mode='a', newline='', encoding='utf-8-sig') as f:
                writer = csv.writer(f)
                writer.writerow(row)
            print(f"   ğŸ’¾ [Logger] ê±°ë˜ ë‚´ì—­ ì €ì¥ ì™„ë£Œ ({self.filename})")
        except Exception as e:
            print(f"   âš ï¸ [Logger] ì €ì¥ ì‹¤íŒ¨: {e}")
2. strategy/signal_maker.py (ìˆ˜ì •)ë³€ê²½ì : check_buy_signal í•¨ìˆ˜ê°€ ì´ì œ (True, ì´ìœ ) ë¿ë§Œ ì•„ë‹ˆë¼ (True, ì´ìœ , ì§€í‘œë°ì´í„°)ë¥¼ í•¨ê»˜ ë°˜í™˜í•©ë‹ˆë‹¤. ê·¸ë˜ì•¼ ë¡œê·¸ì— ê¸°ë¡í•  ìˆ˜ ìˆìœ¼ë‹ˆê¹Œìš”.íŒŒì´ì¬# strategy/signal_maker.py
# [ì—…ë°ì´íŠ¸] ë¡œê·¸ ì €ì¥ì„ ìœ„í•´ ë§¤ìˆ˜ ì‹ í˜¸ ì‹œ 'ì§€í‘œ ë°ì´í„°(analysis)'ë„ í•¨ê»˜ ë°˜í™˜

import pyupbit
from strategy.indicators import TechnicalAnalyzer
from strategy.calculator import TickCalculator
import config

class SignalMaker:
    def __init__(self):
        self.analyzer = TechnicalAnalyzer()
        self.calculator = TickCalculator()

    def get_analysis_only(self, ticker):
        """ë³´ìœ  ì½”ì¸ ë§¤ë„ íŒë‹¨ìš©"""
        try:
            df = pyupbit.get_ohlcv(ticker, interval=config.OHLCV_INTERVAL, count=config.OHLCV_COUNT)
            if df is None: return None
            return self.analyzer.analyze_1m_candle(df)
        except:
            return None

    def check_buy_signal(self, ticker, current_price, current_kimp):
        """
        Return: (is_buy, reason, analysis_dict)
        """
        # 1. ê¹€í”„ í•„í„°
        if current_kimp > config.MAX_KIMP_THRESHOLD:
            return False, f"ê¹€í”„ ê³¼ì—´({current_kimp:.2f}%)", None

        # 2. í‹± íš¨ìœ¨ì„± ì²´í¬
        ticks_to_bep, _ = self.calculator.get_ticks_to_bep(current_price)
        if ticks_to_bep > config.MAX_TICKS_FOR_BEP:
            return False, f"í‹± íš¨ìœ¨ ë‚˜ì¨({ticks_to_bep}í‹±)", None

        # 3. ë°ì´í„° ìˆ˜ì§‘
        try:
            df = pyupbit.get_ohlcv(ticker, interval=config.OHLCV_INTERVAL, count=config.OHLCV_COUNT)
            if df is None: return False, "ë°ì´í„° ì—†ìŒ", None
        except: return False, "API ì˜¤ë¥˜", None

        # 4. ì§€í‘œ ë¶„ì„
        analysis = self.analyzer.analyze_1m_candle(df)
        rsi_14 = analysis['RSI_14']
        rsi_9 = analysis['RSI_9']
        is_bb_touch = analysis['is_oversold']
        vwap = analysis['VWAP']

        # [3ìˆœìœ„] ì—­í”„ë¦¬ë¯¸ì—„ ìŠ¤ë‚˜ì´í¼
        if current_kimp <= config.REVERSE_KIMP_THRESHOLD:
            if rsi_14 < (config.RSI_BUY_THRESHOLD + config.RSI_REVERSE_OFFSET):
                return True, f"ğŸ”¥ ì—­í”„ ìŠ¤ë‚˜ì´í¼", analysis

        # ğŸ¯ [í•µì‹¬] ì •ë°€ ë§¤ìˆ˜ ì „ëµ
        is_rsi_golden_cross = rsi_9 > rsi_14
        is_vwap_support = current_price >= (vwap * config.VWAP_BUY_FACTOR)

        if rsi_14 < config.RSI_BUY_THRESHOLD and is_bb_touch:
            if is_rsi_golden_cross:
                if is_vwap_support:
                    return True, f"âš¡ ê³¨ë“ í¬ë¡œìŠ¤+VWAPì§€ì§€", analysis
                else:
                    return False, f"VWAP ì €í•­", analysis
            else:
                return False, f"ë°˜ë“± ëŒ€ê¸°ì¤‘", analysis
        
        return False, f"ê´€ë§ (RSI:{rsi_14})", analysis
3. main.py (ìµœì¢… ì—°ê²°)ë³€ê²½ì : TradeLoggerë¥¼ ë¶ˆëŸ¬ì˜¤ê³ , ë§¤ìˆ˜/ë§¤ë„ ì„±ê³µ ì‹œ logger.log(...)ë¥¼ í˜¸ì¶œí•˜ì—¬ ì—‘ì…€ì— ê¸°ë¡í•©ë‹ˆë‹¤.íŒŒì´ì¬# main.py
# [ìµœì¢…] TradeLogger íƒ‘ì¬ + ë§¤ë§¤ ì´ë ¥ ì—‘ì…€ ì €ì¥

import asyncio
import config
from data_feed.aggregator import DataAggregator
from strategy.signal_maker import SignalMaker
from execution.order_manager import OrderManager
from execution.risk_manager import RiskManager
from data_feed.macro_client import MacroClient
from market_scanner import get_strategy_recommendation
from trade_logger import TradeLogger  # [ì‹ ê·œ] ë¡œê±° ì„í¬íŠ¸

async def auto_tuner_loop():
    """4ì‹œê°„ë§ˆë‹¤ ì„¤ì • ìë™ íŠœë‹"""
    while True:
        await asyncio.sleep(14400) 
        print(f"\nğŸ§  [Auto Tuner] ì‹œì¥ ë¶„ì„ ë° ì„¤ì • ìµœì í™” ì‹œì‘...")
        try:
            new_settings = get_strategy_recommendation()
            
            if not (10 <= new_settings['RSI_BUY_THRESHOLD'] <= 50):
                continue

            config.TARGET_COINS = new_settings['TARGET_COINS']
            config.FOLLOWER_COINS = new_settings['FOLLOWER_COINS']
            config.RSI_BUY_THRESHOLD = new_settings['RSI_BUY_THRESHOLD']
            config.BB_MULTIPLIER = new_settings['BB_MULTIPLIER']
            config.MAX_KIMP_THRESHOLD = new_settings['MAX_KIMP_THRESHOLD']
            config.REVERSE_KIMP_THRESHOLD = new_settings['REVERSE_KIMP_THRESHOLD']
            config.CURRENT_EXCHANGE_RATE = new_settings['CURRENT_EXCHANGE_RATE']
            
            print(f"âœ… [Tuner] ì—…ë°ì´íŠ¸ ì™„ë£Œ! (íƒ€ê²Ÿ {len(config.TARGET_COINS)}ê°œ)")
        except Exception as e:
            print(f"âš ï¸ [Tuner] ìµœì í™” ì‹¤íŒ¨: {e}")

async def main():
    print(f"========================================")
    print(f"   ğŸ™ 2026 Octopus Bot - Data Logging On")
    print(f"   Mode: {'ğŸ§ª Simulation' if config.IS_SIMULATION else 'ğŸ’³ Real Trading'}")
    print(f"========================================")
    
    # ê°ì²´ ìƒì„±
    aggregator = DataAggregator()
    signal_maker = SignalMaker()
    order_manager = OrderManager()
    risk_manager = RiskManager()
    macro_client = MacroClient()
    logger = TradeLogger()  # [ì‹ ê·œ] ë¡œê±° ìƒì„±

    asyncio.create_task(auto_tuner_loop())
    asyncio.create_task(aggregator.run())
    
    print("â³ ë°ì´í„° ë™ê¸°í™” ì¤‘... (3ì´ˆ)")
    await asyncio.sleep(3)

    while True:
        try:
            # ğŸ›‘ [0] ê±°ì‹œê²½ì œ í•„í„°
            if config.ENABLE_MACRO_FILTER:
                is_risk, reason = macro_client.is_volatility_risk()
                if is_risk:
                    print(f"\nğŸš« [MACRO] ë§¤ë§¤ ì¼ì‹œ ì •ì§€: {reason}")
                    await asyncio.sleep(60)
                    continue 

            print("\r", end="", flush=True) 

            # 0. ìì‚° ì¡°íšŒ
            current_prices = {t: d['upbit'] for t, d in aggregator.market_data.items() if d['upbit']}
            total_assets = order_manager.get_total_assets(current_prices)
            print(f"ğŸ’° {total_assets:,.0f}ì› | ", end="", flush=True)

            # ---------------------------------------------------------
            # ğŸ”¥ [1] ê¸´ê¸‰ ë§¤ìˆ˜ (ê¸‰ë“±ì£¼)
            # ---------------------------------------------------------
            if aggregator.surge_detected:
                print(f"\n\n{aggregator.surge_info}")
                for coin in config.FOLLOWER_COINS:
                    if risk_manager.is_in_cooldown(coin): continue
                    if order_manager.get_balance(coin) > 0: continue
                    
                    price = aggregator.market_data[coin]['upbit']
                    
                    # [ì•ˆì „ ë§¤ìˆ˜]
                    safe_amount = order_manager.calculate_safe_buy_amount(coin, config.TRADE_AMOUNT)
                    
                    if price and safe_amount > 0:
                        # 1. ì£¼ë¬¸ ì‹¤í–‰
                        res = order_manager.buy_limit_safe(coin, config.TRADE_AMOUNT) # ë‚´ë¶€ì—ì„œ safe_amount ë‹¤ì‹œ ê³„ì‚°í•¨
                        if res:
                            order_manager.simulation_buy(coin, safe_amount, price)
                            risk_manager.register_buy(coin)
                            
                            # 2. [ë¡œê·¸ ì €ì¥] ê¸´ê¸‰ ë§¤ìˆ˜ëŠ” ì§€í‘œ ë¶„ì„ ì—†ì´ ì§„ì…í•˜ë¯€ë¡œ analysis=None
                            logger.log("BUY", coin, price, safe_amount/price, "BTCê¸‰ë“±_íŒ”ë¡œì›Œë§¤ìˆ˜", None, 0, 0, total_assets)
                
                aggregator.surge_detected = False
                await asyncio.sleep(3)
                continue

            # ---------------------------------------------------------
            # ğŸ¯ [2] ì¼ë°˜ ë§¤ë§¤
            # ---------------------------------------------------------
            for ticker in list(config.TARGET_COINS.keys()):
                data = aggregator.market_data[ticker]
                price = data['upbit']
                kimp = data['kimp']

                if price is None or kimp is None: continue

                balance = order_manager.get_balance(ticker)
                has_coin = balance > 0 and (balance * price) >= config.MIN_ORDER_VALUE

                # [A] ë§¤ë„ ê´€ë¦¬
                if has_coin:
                    avg_price = order_manager.get_avg_buy_price(ticker)
                    analysis = signal_maker.get_analysis_only(ticker) # ì§€í‘œ ê°€ì ¸ì˜¤ê¸°
                    
                    action, msg = risk_manager.check_exit_signal(ticker, price, avg_price, analysis)
                    
                    if action != "HOLD":
                        print(f"\n{msg}")
                        ob_health = order_manager.analyze_orderbook_health(ticker)
                        sell_strategy = "LIMIT"
                        if ob_health == "BAD" or "ì†ì ˆ" in msg: sell_strategy = "MARKET"

                        current_vol = order_manager.get_balance(ticker)
                        ratio = 1.0 if action == "SELL_ALL" else config.PARTIAL_SELL_RATIO
                        sell_amount = current_vol * ratio

                        # 1. ë§¤ë„ ì‹¤í–‰
                        res = order_manager.sell_percentage(ticker, ratio, sell_strategy)
                        if res:
                            order_manager.simulation_sell(ticker, price)
                            
                            # 2. [ë¡œê·¸ ì €ì¥] ë§¤ë„ ê¸°ë¡
                            profit_pct = ((price - avg_price) / avg_price) * 100
                            logger.log("SELL", ticker, price, sell_amount, msg, analysis, kimp, profit_pct, total_assets)

                    else:
                        print(f"[{ticker.split('-')[1]} {msg}] ", end="", flush=True)

                # [B] ë§¤ìˆ˜ ê´€ë¦¬
                else:
                    if risk_manager.is_in_cooldown(ticker): continue

                    # [ìˆ˜ì •] analysisë„ í•¨ê»˜ ë°›ìŒ
                    is_buy, reason, analysis = signal_maker.check_buy_signal(ticker, price, kimp)
                    
                    if is_buy:
                        print(f"\nğŸ”¥ {ticker} ì§„ì…! ({reason})")
                        
                        # [ì•ˆì „ ë§¤ìˆ˜ ê³„ì‚°]
                        safe_amount = order_manager.calculate_safe_buy_amount(ticker, config.TRADE_AMOUNT)
                        
                        if safe_amount > 0:
                            # 1. ë§¤ìˆ˜ ì‹¤í–‰
                            res = order_manager.buy_limit_safe(ticker, config.TRADE_AMOUNT)
                            if res:
                                order_manager.simulation_buy(ticker, safe_amount, price)
                                risk_manager.register_buy(ticker)
                                
                                # 2. [ë¡œê·¸ ì €ì¥] ë§¤ìˆ˜ ê¸°ë¡
                                vol = safe_amount / price
                                logger.log("BUY", ticker, price, vol, reason, analysis, kimp, 0, total_assets)
                                await asyncio.sleep(1)
                    else:
                        icon = "ğŸŸ¢" if is_buy else "âšª"
                        print(f"[{ticker.split('-')[1]} {icon}] ", end="", flush=True)

            await asyncio.sleep(config.LOOP_DELAY)

        except Exception as e:
            print(f"\nâš ï¸ Error: {e}")
            await asyncio.sleep(1)

if __name__ == "__main__":
    try:
        asyncio.set_event_loop_policy(asyncio.WindowsSelectorEventLoopPolicy())
        asyncio.run(main())
    except KeyboardInterrupt:
        print("\nğŸ›‘ ë´‡ ì¢…ë£Œ")
ğŸ“Š ì´ì œ ì´ë ‡ê²Œ ê¸°ë¡ë©ë‹ˆë‹¤ì´ì œ ë´‡ì„ ëŒë¦¬ë©´ trade_history.csv íŒŒì¼ì´ ìƒê¸°ê³ , ì•„ë˜ì²˜ëŸ¼ ìƒì„¸í•˜ê²Œ ê¸°ë¡ë©ë‹ˆë‹¤.íƒ€ì„ìŠ¤íƒ¬í”„í–‰ë™ì¦ê¶Œ ì‹œì„¸ í‘œì‹œê¸°ê°€ê²©ì´ìœ RSI_14RSI_9ê¹€14:00:01ì‚¬ë‹¤KRW-XRP800ê³¨ë“ í¬ë¡œìŠ¤+VWAPì§€ì§€28.532.11.2%14:30:05íŒ”ë‹¤KRW-XRP8201ì°¨ ëª©í‘œ ë‹¬ì„± (BBì¤‘ì‹¬ì„ )55.060.21.5%15:10:00íŒ”ë‹¤KRW-BTC1.2ì–µğŸ“‰ VWAP ì§€ì§€ ë¶•ê´´42.038.02.1%ë‚˜ì¤‘ì— ì´ ì—‘ì…€ íŒŒì¼ì„ ì—´ì–´ì„œ "ì–´? RSI 28ì¼ ë•Œ ìƒ€ëŠ”ë° ì™œ ë¬¼ë ¸ì§€? ì•„, ê¹€í”„ê°€ ê°‘ìê¸° íŠ€ì—ˆêµ¬ë‚˜" í•˜ê³  ë¶„ì„í•´ì„œ ì „ëµì„ ìˆ˜ì •í•˜ì‹œë©´ ë©ë‹ˆë‹¤.